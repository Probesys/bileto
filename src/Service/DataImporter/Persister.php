<?php

// This file is part of Bileto.
// Copyright 2022-2024 Probesys
// SPDX-License-Identifier: AGPL-3.0-or-later

namespace App\Service\DataImporter;

use App\Entity;
use Doctrine\ORM\EntityManagerInterface;
use Doctrine\ORM\Mapping;

/**
 * Allow to store (insert) entities in database in a more efficient way than
 * the Doctrine UnitOfWork.
 *
 * This class makes some assumptions on the entities to import, such as
 * "standard" associations with target entities having an integer id. It allows
 * to write simpler code, and to improve the performance.
 *
 * There's probably still room for performance improvements, but it's
 * already way better than the UnitOfWork mechanism. Note that we insert
 * entities one by one in the database instead of doing a bulk insert. This is
 * because we need to get the generated ids in order to be able to save
 * entities with associations to other entities.
 */
class Persister
{
    public function __construct(
        private EntityManagerInterface $entityManager,
    ) {
    }

    /**
     * Insert the given entities in the database.
     *
     * By default, only standard fields, owned ToOne associations and
     * ManyToMany associations are saved. If the entities have OneToMany
     * associations, it is expected to save the target entities separately.
     * Though, you can force the method to save the target entities by passing
     * the association name in the $additionalAssociations array.
     *
     * @param Entity\EntityInterface[] $entities
     * @param string[] $additionalAssociations
     */
    public function insertEntities(array $entities, array $additionalAssociations = []): void
    {
        if (count($entities) === 0) {
            return;
        }

        $entityClass = $entities[0]::class;

        $databaseConnection = $this->entityManager->getConnection();
        $metadata = $this->entityManager->getClassMetadata($entityClass);

        $tableName = $metadata->getTableName();
        $fieldNames = $metadata->getFieldNames();
        $associationMappings = $metadata->getAssociationMappings();

        // Exclude the id from the field names. We make the assumption that the
        // id is generated by the database.
        $fieldNames = array_diff($fieldNames, ['id']);

        $columns = [];
        $types = [];
        $manyToManyAssociations = [];

        // Populate the columns and types variables from the "standard" fields
        // of the entity.
        foreach ($fieldNames as $fieldName) {
            $fieldMapping = $metadata->getFieldMapping($fieldName);
            $columnName = $fieldMapping->columnName;

            $columns[$columnName] = $fieldName;
            $types[$columnName] = $fieldMapping->type;
        }

        foreach ($associationMappings as $associationName => $association) {
            if ($association->isToOneOwningSide()) {
                // In the case of a OneToOne or ManyToOne association, the
                // foreign key is on the entity side. Thus, we insert the
                // column as for the other standard fields.

                $countJoinColumns = count($association->joinColumns);
                if ($countJoinColumns !== 1) {
                    throw new \LogicException(
                        "It is expected to have 1 JoinColumn in a ToOne association, got {$countJoinColumns}"
                    );
                }

                $columnName = $association->joinColumns[0]->name;

                $columns[$columnName] = $associationName;
                // We make the assumption that the foreign key is always an
                // integer. At the moment, it's always true in Bileto.
                $types[$columnName] = 'integer';
            } elseif ($association->isManyToManyOwningSide()) {
                // ManyToMany associations are handled separately.
                $manyToManyAssociations[$associationName] = $association;
            }
        }

        foreach ($entities as $entity) {
            $values = [];
            $associationsToUpdate = [];

            // Iterate over the columns variable to get the different values
            // from the entity.
            foreach ($columns as $column => $fieldName) {
                $value = $metadata->getFieldValue($entity, $fieldName);

                if ($value instanceof Entity\EntityInterface) {
                    // We're handling an association and we want to insert its
                    // id in the database.
                    $value = $value->getId();

                    if ($value === null) {
                        // If the id is null, it means that the associated
                        // entity is not saved yet in the database. It happens
                        // for associations referring to entities contained in
                        // many-to-many associations.
                        // For instance Ticket.solution refers to the
                        // many-to-many association Ticket.messages. However,
                        // the messages are saved only once the ticket is
                        // created. So we need to update Ticket.solution after
                        // that.
                        $associationsToUpdate[$column] = $fieldName;
                    }
                }

                $values[$column] = $value;
            }

            // This is it! We insert the values in the database.
            $databaseConnection->insert($tableName, $values, $types);

            // And we get the generated id back from the database.
            $id = $databaseConnection->lastInsertId();
            $metadata->setIdentifierValues($entity, ['id' => $id]);

            // Handle the ManyToMany associations only once the entity is
            // saved.
            foreach ($manyToManyAssociations as $association) {
                $this->insertManyToMany($entity, $association);
            }

            // And handle the not owned-side associations that we were asked to
            // save by the calling method.
            foreach ($additionalAssociations as $associationName) {
                $additionalEntities = $metadata->getFieldValue($entity, $associationName);
                $this->insertEntities($additionalEntities->toArray());
            }

            // Finally, update the OneToOne and/or ManyToOne associations that
            // weren't ready yet when we tried to get the association id (see
            // above).
            $this->updateEntityAssociations($entity, $associationsToUpdate);
        }
    }

    /**
     * Insert a ManyToMany association.
     */
    private function insertManyToMany(
        Entity\EntityInterface $sourceEntity,
        Mapping\ManyToManyOwningSideMapping $association
    ): void {
        assert($association->isManyToManyOwningSide());

        $databaseConnection = $this->entityManager->getConnection();

        $tableName = $association->joinTable->name;

        $joinColumns = array_merge(
            $association->joinTable->joinColumns,
            $association->joinTable->inverseJoinColumns
        );

        $countJoinColumns = count($joinColumns);
        if ($countJoinColumns !== 2) {
            throw new \LogicException(
                "It is expected to have 2 JoinColumns in a ManyToMany association, got {$countJoinColumns}"
            );
        }

        $columnName1 = $joinColumns[0]->name;
        $columnName2 = $joinColumns[1]->name;

        $columns = [$columnName1, $columnName2];
        // As above, we make the assumption that the type of the foreign keys
        // is integer. This may be false in other projects, but not in Bileto.
        $types = ['integer', 'integer'];

        $metadata = $this->entityManager->getClassMetadata($sourceEntity::class);
        $relatedEntities = $metadata->getFieldValue($sourceEntity, $association->fieldName);

        foreach ($relatedEntities as $relatedEntity) {
            if (!$relatedEntity instanceof Entity\EntityInterface) {
                throw new \LogicException(
                    'Only EntityInterface entities can be saved through a ManyToMany association'
                );
            }

            $values = [
                $columnName1 => $sourceEntity->getId(),
                $columnName2 => $relatedEntity->getId(),
            ];

            $databaseConnection->insert($tableName, $values, $types);
        }
    }

    /**
     * Update the given associations of the entity.
     *
     * @param array<string, string> $associationsNames
     */
    private function updateEntityAssociations(
        Entity\EntityInterface $entity,
        array $associationsNames,
    ): void {
        if (empty($associationsNames)) {
            return;
        }

        $entityClass = $entity::class;

        $databaseConnection = $this->entityManager->getConnection();
        $metadata = $this->entityManager->getClassMetadata($entityClass);

        $tableName = $metadata->getTableName();

        $types = [];
        $values = [];

        foreach ($associationsNames as $column => $fieldName) {
            $value = $metadata->getFieldValue($entity, $fieldName);

            if (!$value instanceof Entity\EntityInterface) {
                throw new \LogicException("The association {$entityClass}#{$fieldName} must be an EntityInterface");
            }

            // Earlier, this value was null. But since then, the targeted
            // entity should have been saved in the database.
            $value = $value->getId();

            if ($value === null) {
                throw new \LogicException("The association {$entityClass}#{$fieldName} should not be null");
            }

            $types[$column] = 'integer';
            $values[$column] = $value;
        }

        // Finally, update the entity with the new associations values.
        $criteria = ['id' => $entity->getId()];
        $databaseConnection->update($tableName, $values, $criteria, $types);
    }
}
